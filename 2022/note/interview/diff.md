# diff

## 2022-7-24

### 观看答案前

- 有虚拟 dom 的地方必然会存在 `diff算法`
  - 当 `虚拟dom` 新旧 dom 发生改变的时候，通过 diff 算法， 可以吧算法复杂度 弄到 O(N)
- diff 算法的 主要策略是 通过 `深度优先 => 同级比较`
  - 也就是 如果 新旧 dom 都有子孩子的情况下， 会先去对比，自孩子
  - 同层比较 也就是， 如果少 就加， 如果多 就删， 相同就跳过
- 里面最主要的一个算法就是 `updateChilren` 这个函数方法
  - 他通过 四次收尾对比的方法，来进行更加生层次的比较来进行处理

### 观看答案后

- 第一点
  - 将变化的地方更新到真实 dom
  - 高效的手法
- vue2 中
  - 因为 `watcher` 变成了每一个组件有一个这玩意，只有通过 diff 才能更加细致的找到问题发生的地方
- diff 算法执行的时候，通常是在 更新函数执行的时候
  - 这个过程叫做 `patch` 打补丁
- 通过头尾节点比较，也会借助 key 来进行比较， 所以 patch 的过程是比较快的

## 林一三 的博客

### 介绍

- 可能存在一些问题，或者说不够详细，但，是是没有任何问题的
- [参考博客](https://juejin.cn/post/6994959998283907102#heading-9)

### 内容小总结

#### 流程

- 当我的数据更新之后，出发 `setter` 并通过 `dep.notice` 通知 每个组件的 `watcher(订阅者)` ，这些订阅者调用 `patch` 给 `真实dom` 打补丁 ，更新相应的区域

#### patch

- 对于两个节点的 开始方法
- 里面通过各种方式进行对于 两个节点的不同
- 之后进行一个 添加和删除的操作都是有可能的

#### sameVnode

- 判断两个节点是不是同一种类似的节点
  - 如果是同一种类似才有递归的理由
  - 不是就可以执行替换操作了 ，删除和添加操作等等

#### patchVnode

- 判断对于 元素是需要删除还是添加还是更新的操作的函数

#### updateChildren

- 最重要的一个方法
- `首尾指针法` 重点
  - 通过四个 头尾指针 的比较和 key 值得映射关系，可以更快的执行 更新操作

## 犹大解析 diff 算法

### 介绍

- diff 算法 并不一定是为了解决真实 dom 慢的原因，可能还有许多其它的原因才是一个重点
  - 虚拟 dom 价值主要是提升开发效率，和多端适配。强调性能的面试官

### 小总结

#### 原生 DOM 操作 vs. 通过框架封装操作

- 这就是一个 性能和可维护性的 来回取舍问题
- 使用 `虚拟dom` 可以然你的 dom 操作 变成一个声明式 的感觉
- 在原生 dom 操作层
  - 底层会针对这个 所有的上层 api 做出更多的优化
  - 每一个 benchmark， 都会有对应的手动优化
  - 手动优化的意思就是
    - 每个更改的地方都用 我对应的原生 dom 操作进行操作吗？
- 虚拟 dom
  - 放弃了上面的手动优化，但是我不需要对每一个 情况做出兼容操作这样
  - 然后再这些前提下，性能还能过得去

#### 对 React 的 Virtual DOM 的误解

- 原生计算 虚拟 dom 变化的消耗会比 dom 全部操作的效率快的多
  - react 初始化渲染的时候，必然会比 vue 要快
  - 一个是组件操作级别的，一个是 每一个响应式数据，都会有一个 viewmodel 来进行控制
  - vue2 需要更多的优化，才能更好地处理问题这样
    - 通过一个key的优化就是一个很好的优化 
- 注意angular 的数据响应式 是 一个数据改变所有的数据全部进行变动，但是更改只是 对应的dom节点这样
  - 这个不知道后续优化的怎么样了

#### 性能比较也要看场合
- 初始渲染的时候，react的优势没有办法比较
- 小数据的更新的时候，肯定就可以很好用到了 vue的数据收集
  - 收集的负担很小，更新起来也会很快
- 大数据 angular 会不会就有了优势
  - 就算是这样，react的优势 也没有出来